\documentclass[12pt]{article}

%\VignettePackage{doBy}
%\VignetteIndexEntry{population means}
%\VignetteIndexEntry{LSMEANS}


\usepackage{a4wide,hyperref}
\usepackage[T1]{fontenc}
\usepackage{url,a4}
\usepackage{boxedminipage,color,xcolor}

\RequirePackage{color,fancyvrb,amsmath,amsfonts}
\DeclareMathOperator{\EE}{\mathbb{E}}

\usepackage{framed}
\usepackage{comment}
\definecolor{shadecolor}{gray}{0.91}
\def\R{\texttt{R}}
\def\code#1{\texttt{#1}}

\title{Population means (LSMEANS), contrasts and estimable functions 
  in the \texttt{doBy} package}
\author{Søren Højsgaard and Ulrich Halekoh\\ Department og Genetics
  and Biotechnology\\ Aarhus University}

\begin{document}
\renewenvironment{Schunk}{\begin{shaded}\small}{\end{shaded}}

\maketitle

\hrule
\tableofcontents

\parindent0pt
\parskip5pt

%\tableofcontents
\setkeys{Gin}{height=3in}
\SweaveOpts{keep.source=T}

\section{Introduction}
\label{sec:xxx}

This is a working document; please feel free to suggest improvements. 

\section{Population means (LSMEANS)}
\label{sec:xxx}

Population means (also known as LSMEANS in SAS jargon) are much used in
some sciences. 
Consider these data:
@ 
<<>>=
library(doBy)
dd <- expand.grid(A=factor(1:3),B=factor(1:3),C=factor(1:2))
dd$y <- rnorm(nrow(dd))
dd$x <- rnorm(nrow(dd))^2
dd$z <- rnorm(nrow(dd))
head(dd,10)
@ %def 

Consider the additive model:
@ 
<<>>=
mm <- lm(y~A+B+C, data=dd)
coef(mm)
@ %def 

This is a model for the conditional mean $\EE(y|A,B,C)$. Sometimes one
is interested in quantities like $\EE(y|A)$. This quantity can not
formally be found unless $B$ and $C$ are random variables such that we
may find $\EE(y|A)$ by integration. 

However, suppose that $A$ is a treatment of main interest, $B$ is a
blocking factor and $C$ is a day. Then it is tempting to average
$\EE(y|A,B,C)$ over $B$ and $C$ (average over block and day) 
and think of this average as $\EE(y|A)$. 

\subsection{A brute--force calculation}
\label{sec:xxx}

The population mean for $A=1$ can be found as:

@ 
<<>>=
w <- c(1, 0, 0, 1/3, 1/3, 1/2)
coef(mm)*w
sum(coef(mm)*w)
@ %def 

Notice that although $B$ has 3 levels we only get two terms of $1/3$
because the parameter for $B=1$ is set to zero to obtain
identifiability. Similarly for $C$ which has 2 levels and therefore we
only get one term of $1/2$. 

We may find the population mean for all three levels of $A$ as
@ 
<<>>=
W <- matrix(c(1, 0, 0, 1/3, 1/3, 1/2,
              1, 1, 0, 1/3, 1/3, 1/2,
              1, 0, 1, 1/3, 1/3, 1/2),nr=3, byrow=TRUE)
W
W %*% coef(mm)
@ %def 

Notice that the matrix W is based on that the first level of $A$ is
set as the reference level. If the reference level is changed then so
must $W$ be. 

\subsection{Using \code{esticon()}}
\label{sec:xxx}

The \code{esticon()} function in the \code{doBy} package be used for
calculating such quantities along with standard errors, confidence
limits etc. 
@ 
<<>>=
esticon(mm, W)
@ %def 

\section{Using \code{popMatrix()} and \code{popMeans()}}
\label{sec:xxx}

Writing such matrices by hand is somewhat tedious. In addition, there
is a potential risk of getting the wrong answer if the the reference
level has been changed.

The
\code{popMatrix()} function provides some help. The above \verb+W+ matrix is  constructed by
@ 
<<>>=
pma <- popMatrix(mm,effect='A')
@ %def 

More details about how the matrix was constructed is provided by the
\code{summary()} function:
@ 
<<>>=
summary(pma)
@ %def 



The \code{popMeans()} function is simply a wrapper around first a call
to \code{popMatrix()} followed by a call to (by default) \code{esticon()}:
@ 
<<>>=
pme <- popMeans(mm, effect='A')
@ %def 

More details about how the matrix was constructed is provided by the
\code{summary()} function:
@ 
<<>>=
summary(pme)
@ %def 




The \verb+effect+ argument requires  to calculate the LSMEANS at \emph{all} levels of
$A$ aggregating across the levels of the other variables in the data.
 
Likewise we may do:
@ 
<<>>=
popMatrix(mm,effect=c('A','C'))
@ %def 

Consequently
@ 
<<>>=
popMeans(mm)
@ %def 
gives the ``total average''.


\subsection{Using the \code{at} argument}

We may be interested in finding the population means 
at all levels of  $A$
but only at $C=1$. This is obtained by using the \code{at} argument:
@ 
<<>>=
popMatrix(mm,effect='A', at=list(C='1'))
@ %def 
Notice here that average is only taken over $B$. Another way of
creating the population means 
at  all levels of $(A,C)$ is therefore
<<>>=
popMatrix(mm,effect='A', at=list(C=c('1','2')))
@ %def 


We may have several variables in the \code{at} argument:
@ 
<<>>=
popMatrix(mm,effect='A', at=list(C=c('1','2'), B='1'))
@ %def 

\subsection{Ambiguous specification}

There is room for an ambiguous specification if a variable appears in
both the \code{effect} and the \code{at} argument, such as
@ 
<<>>=
popMatrix(mm,effect=c('A','C'), at=list(C='1'))
@ %def 

This ambiguity is due to the fact that the \verb+effect+ argument asks
for the  LSMEANS at all levels of the variables but  the \verb+at+  chooses only specific levels.


In this case of ambiguity  any variable in the \code{at} argument is removed from
the \code{effect} argument such as the statement above is equivalent
to 
@ 
<<eval=F>>=
popMatrix(mm,effect='A', at=list(C='1'))
@ %def 

\subsection{Using covariates}

Next consider the model where a covariate is included:
@ 
<<>>=
mm2 <- lm(y~A+B+C+C:x, data=dd)
coef(mm2)
@ %def 

In this case we get 
<<>>=
popMatrix(mm2,effect='A', at=list(C='1'))
@ %def 

Above, $x$ has been replaced by its average and that is the general
rule for models including covariates. However we may use the \code{at}
argument to ask for calculation of the LSMEANS at some user-specified value of $x$, say 12:
<<>>=
popMatrix(mm2,effect='A', at=list(C='1',x=12))
@ %def 


\subsection{Using transformed covariates}

Next consider the model where a  transformation of a covariate is included:
@ 
<<>>=
mm3 <- lm(y~A+B+C+C:log(x), data=dd)
coef(mm3)
@ %def 

In this case we can not use \code{popMatrix}. Instead we have first to
generate a new variable, say \verb+log.x+, with \verb+log.x+$=\log(x)$, in the data and then proceed as

<<>>=
dd <- transform(dd, log.x = log(x))
mm3 <- lm(y~A+B+C+C:log.x, data=dd)
popMatrix(mm3,effect='A', at=list(C='1'))
@ %def 



\section{The \code{engine} argument of {\tt popMeans}}

The \verb+popMatrix+ is a function to generate a linear tranformation matrix of the model
parameters with emphasis on  constructing such matrices for LSMEANS.
\verb+popMeans+ envokes by default the \verb+esticon+ function on this
linear transformation matrix for calculating parameter estimates and
confidecne intervals.
A similar function to \verb+esticon+ is the \verb+glht+ function of the \verb+multcomp+
 package.
 
 The \code{glht()} function 
 can be chosen via the \verb+engine+ argument of \verb+popMeans+.
<<>>=
 library(multcomp)
g<-popMeans(mm,effect='A', at=list(C='1'),engine="glht")
g
@ %def 
 
This allows to apply the methods available on the \verb+glht+ object like
<<>>=
summary(g,test=univariate())
confint(g,calpha=univariate_calpha())
@
which yield the same results as the \verb+esticon+ function.

By default the functions will adjust the tests  and confidence intervals for multiplicity
<<>>=
summary(g)
confint(g)
@
 











\end{document}

















