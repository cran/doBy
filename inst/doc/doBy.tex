\documentclass[11pt]{article}
\usepackage{inputenc,hyperref,a4,color,boxedminipage,Sweave}
%\VignetteIndexEntry{doBy}
%\VignettePackage{doBy}
%\VignetteDepends{}

\title{Introduction to the \texttt{doBy} package}
\author{Søren Højsgaard}
\begin{document}
\maketitle
\tableofcontents

\renewenvironment{Schunk}{\begin{center}
    \scriptsize
    \begin{boxedminipage}{0.95\textwidth}}{
    \end{boxedminipage}\end{center}}


\def\proglang#1{{#1}}
\def\pkg#1{{#1}}
\def\doby{\pkg{doBy}}
\def\code#1{\texttt{#1}}
\def\shd#1{\footnote{SHD: #1}}
\def\summaryby{\code{summaryBy}}




\section{Introduction} 
\label{sec:introduction}

The \doby{} package grew out of a need to calculate groupwise summary
statistics in a simple way, much in the spirit of \code{PROC SUMMARY}
of the \proglang{SAS} system.

\begin{Schunk}
\begin{Sinput}
> library(doBy)
\end{Sinput}
\begin{Soutput}
Hmisc library by Frank E Harrell Jr

Type library(help='Hmisc'), ?Overview, or ?Hmisc.Overview')
to see overall documentation.

NOTE:Hmisc no longer redefines [.factor to drop unused levels when
subsetting.  To get the old behavior of Hmisc type dropUnusedLevels().
\end{Soutput}
\end{Schunk}


\section{Data}


\subsection{CO2 data} 
\label{sec:co2data}

The \code{CO2} data frame has 84 rows and 5 columns of data from an
experiment on the cold tolerance of the grass species {\em Echinochloa
crus-galli}.  
To limit the amount of output we modify names and levels of variables
as follows
\begin{Schunk}
\begin{Sinput}
> data(CO2)
> CO2 <- transform(CO2, Treat = Treatment, Treatment = NULL)
> levels(CO2$Treat) <- c("nchil", "chil")
> levels(CO2$Type) <- c("Que", "Mis")
> CO2 <- subset(CO2, Plant %in% c("Qn1", "Qc1", "Mn1", "Mc1"))
\end{Sinput}
\end{Schunk}
whereby the data becomes
\begin{Schunk}
\begin{Sinput}
> CO2
\end{Sinput}
\begin{Soutput}
   Plant Type conc uptake Treat
1    Qn1  Que   95   16.0 nchil
2    Qn1  Que  175   30.4 nchil
3    Qn1  Que  250   34.8 nchil
4    Qn1  Que  350   37.2 nchil
5    Qn1  Que  500   35.3 nchil
6    Qn1  Que  675   39.2 nchil
7    Qn1  Que 1000   39.7 nchil
22   Qc1  Que   95   14.2  chil
23   Qc1  Que  175   24.1  chil
24   Qc1  Que  250   30.3  chil
25   Qc1  Que  350   34.6  chil
26   Qc1  Que  500   32.5  chil
27   Qc1  Que  675   35.4  chil
28   Qc1  Que 1000   38.7  chil
43   Mn1  Mis   95   10.6 nchil
44   Mn1  Mis  175   19.2 nchil
45   Mn1  Mis  250   26.2 nchil
46   Mn1  Mis  350   30.0 nchil
47   Mn1  Mis  500   30.9 nchil
48   Mn1  Mis  675   32.4 nchil
49   Mn1  Mis 1000   35.5 nchil
64   Mc1  Mis   95   10.5  chil
65   Mc1  Mis  175   14.9  chil
66   Mc1  Mis  250   18.1  chil
67   Mc1  Mis  350   18.9  chil
68   Mc1  Mis  500   19.5  chil
69   Mc1  Mis  675   22.2  chil
70   Mc1  Mis 1000   21.9  chil
\end{Soutput}
\end{Schunk}


\subsection{Airquality data} 

The \code{airquality}
dataset contains  air quality measurements in New York, May to
September 1973. The months are coded as $5,\dots,9$.  
To limit the output we only consider data for two months:


\section{The \code{summaryBy} function}
\label{sec:summaryBy}

The \summaryby function is used for calculating quantities like
``the mean and variance of $x$ and $y$ for
each combination of two factors $A$ and $B$''. 


\begin{description}
\item[Basic usage:] 

For example, the mean, median and variance of \code{uptake} and
\code{conc} for each value of \code{Plant} is obtained by:
\begin{Schunk}
\begin{Sinput}
> summaryBy(conc + uptake ~ Plant, data = CO2, FUN = function(x) {
+     c(m = mean(x), v = var(x))
+ })
\end{Sinput}
\begin{Soutput}
  Plant conc.m conc.v uptake.m uptake.v
1   Mc1    435 100950    18.00    16.96
2   Mn1    435 100950    26.40    75.59
3   Qc1    435 100950    29.97    69.47
4   Qn1    435 100950    33.23    67.48
\end{Soutput}
\end{Schunk}
Alternatively,
\begin{Schunk}
\begin{Sinput}
> myfun <- function(x) {
+     c(m = mean(x), v = var(x))
+ }
> summaryBy(conc + uptake ~ Plant, data = CO2, FUN = myfun)
\end{Sinput}
\begin{Soutput}
  Plant conc.m conc.v uptake.m uptake.v
1   Mc1    435 100950    18.00    16.96
2   Mn1    435 100950    26.40    75.59
3   Qc1    435 100950    29.97    69.47
4   Qn1    435 100950    33.23    67.48
\end{Soutput}
\end{Schunk}

Defining the function to return named values as above is the
recommended use of \summaryby. 
If the result of the function(s) are not named, then the names in the
output data in general become less intuitive:
\begin{Schunk}
\begin{Sinput}
> summaryBy(conc + uptake ~ Plant, data = CO2, FUN = function(x) {
+     c(mean(x), var(x))
+ })
\end{Sinput}
\begin{Soutput}
  Plant conc.stat1 conc.stat2 uptake.stat1 uptake.stat2
1   Mc1        435     100950        18.00        16.96
2   Mn1        435     100950        26.40        75.59
3   Qc1        435     100950        29.97        69.47
4   Qn1        435     100950        33.23        67.48
\end{Soutput}
\begin{Sinput}
> myfun <- function(x) {
+     c(mean(x), var(x))
+ }
> summaryBy(conc + uptake ~ Plant, data = CO2, FUN = myfun)
\end{Sinput}
\begin{Soutput}
  Plant conc1  conc2 uptake1 uptake2
1   Mc1   435 100950   18.00   16.96
2   Mn1   435 100950   26.40   75.59
3   Qc1   435 100950   29.97   69.47
4   Qn1   435 100950   33.23   67.48
\end{Soutput}
\end{Schunk}


\item[Using a list of functions:] 
It is possible to apply a list of functions (but note the difference
in naming the output variables depending on whether the output of the
functions are named or not):
\begin{Schunk}
\begin{Sinput}
> mymed <- function(x) c(med = median(x))
> foo <- function(x) c(median(x))
> summaryBy(uptake ~ Plant, data = CO2, FUN = c(mean, var, mymed, 
+     foo))
\end{Sinput}
\begin{Soutput}
  Plant uptake.mean uptake.var uptake.med uptake.foo
1   Mc1       18.00      16.96       18.9       18.9
2   Mn1       26.40      75.59       30.0       30.0
3   Qc1       29.97      69.47       32.5       32.5
4   Qn1       33.23      67.48       35.3       35.3
\end{Soutput}
\end{Schunk}



\item[Copying variables out with the \code{id} argument:] 
To get the value of the \code{Type} and \code{Treat} in the first row of the
groups (defined by the values of \code{Plant}) copied to the output
dataframe we use the \code{id} argument:
as:
\begin{Schunk}
\begin{Sinput}
> summaryBy(conc + uptake ~ Plant, data = CO2, FUN = function(x) {
+     c(m = mean(x), med = median(x), v = var(x))
+ }, id = ~Type + Treat)
\end{Sinput}
\begin{Soutput}
  Plant conc.m conc.med conc.v uptake.m uptake.med uptake.v Type Treat
1   Mc1    435      350 100950    18.00       18.9    16.96  Mis  chil
2   Mn1    435      350 100950    26.40       30.0    75.59  Mis nchil
3   Qc1    435      350 100950    29.97       32.5    69.47  Que  chil
4   Qn1    435      350 100950    33.23       35.3    67.48  Que nchil
\end{Soutput}
\end{Schunk}


\item[Statistics on functions of data:] 
We may want to calculate the mean and variance for the logarithm of
\code{uptake}, for \code{uptake}+\code{conc} (not likely to be a
useful statistic) as well as for \code{uptake} and
\code{conc}. This can be achieved as
\begin{Schunk}
\begin{Sinput}
> summaryBy(log(uptake) + I(conc + uptake) + conc + uptake ~ Plant, 
+     data = CO2, FUN = function(x) {
+         c(m = mean(x), v = var(x))
+     })
\end{Sinput}
\end{Schunk}


\item[The dot (".") on the left hand side of a formula:] 
However it is simpler to use the dot (".") on the left hand side of
the formula. The dot means ``all numerical variables which do not
appear elsewhere'' (i.e.\ on the right hand side of the formula and in
the \code{id} statement): 
\begin{Schunk}
\begin{Sinput}
> summaryBy(log(uptake) + I(conc + uptake) + . ~ Plant, data = CO2, 
+     FUN = function(x) {
+         c(m = mean(x), v = var(x))
+     })
\end{Sinput}
\begin{Soutput}
  Plant log(uptake).m log(uptake).v conc + uptake.m conc + uptake.v conc.m
1   Mc1         2.864       0.06874           453.0          103157    435
2   Mn1         3.209       0.17928           461.4          105642    435
3   Qc1         3.356       0.11873           465.0          105297    435
4   Qn1         3.467       0.10168           468.2          104747    435
  conc.v uptake.m uptake.v
1 100950    18.00    16.96
2 100950    26.40    75.59
3 100950    29.97    69.47
4 100950    33.23    67.48
\end{Soutput}
\end{Schunk}

\item[The dot (".") on the right hand side of a formula:] 
The dot (".") can also be used on the right hand side of the formula
where it refers to ``all non--numerical variables which are not
specified elsewhere'':
\begin{Schunk}
\begin{Sinput}
> summaryBy(log(uptake) ~ Plant + ., data = CO2, FUN = function(x) {
+     c(m = mean(x), v = var(x))
+ })
\end{Sinput}
\begin{Soutput}
  Plant Type Treat log(uptake).m log(uptake).v
1   Mc1  Mis  chil         2.864       0.06874
2   Mn1  Mis nchil         3.209       0.17928
3   Qc1  Que  chil         3.356       0.11873
4   Qn1  Que nchil         3.467       0.10168
\end{Soutput}
\end{Schunk}


\item[Using ``1'' on the right hand side of the formula:] Using 1 on the
  right hand side means no grouping:
\begin{Schunk}
\begin{Sinput}
> summaryBy(log(uptake) ~ 1, data = CO2, FUN = function(x) {
+     c(m = mean(x), v = var(x))
+ })
\end{Sinput}
\begin{Soutput}
  log(uptake).m log(uptake).v
1         3.224        0.1577
\end{Soutput}
\end{Schunk}


\item[Preserving names of variables:] 
If the function applied to data only returns one value, it is possible
to force that the summary variables retain the original names by
setting \code{keep.names=TRUE}. A
typical use of this could be
\begin{Schunk}
\begin{Sinput}
> summaryBy(conc + uptake + log(uptake) ~ Plant, data = CO2, FUN = mean, 
+     id = ~Type + Treat, keep.names = TRUE)
\end{Sinput}
\begin{Soutput}
  Plant conc uptake log(uptake) Type Treat
1   Mc1  435  18.00       2.864  Mis  chil
2   Mn1  435  26.40       3.209  Mis nchil
3   Qc1  435  29.97       3.356  Que  chil
4   Qn1  435  33.23       3.467  Que nchil
\end{Soutput}
\end{Schunk}
\end{description}



\section{The \code{orderBy} function} 
\label{orderBy}

Ordering (or sorting) a data frame is possible with the \code{orderBy}
function. 
Suppose we want to order the rows of the the \code{airquality} data by \code{Temp} and by
\code{Month} (within \code{Temp}) and that the ordering should be
decreasing. This can be achieved by:
\begin{Schunk}
\begin{Sinput}
> x <- orderBy(~Temp + Month, data = aq, decreasing = T)
\end{Sinput}
\end{Schunk}
The first lines of the result are:
\begin{Schunk}
\begin{Sinput}
> head(x)
\end{Sinput}
\begin{Soutput}
   Ozone Solar.R Wind Temp Month Day
42    NA     259 10.9   93     6  11
43    NA     250  9.2   92     6  12
40    71     291 13.8   90     6   9
39    NA     273  6.9   87     6   8
41    39     323 11.5   87     6  10
36    NA     220  8.6   85     6   5
\end{Soutput}
\end{Schunk}

\section{The \code{splitBy} function} 
\label{splitBy}

Suppose we want to split the \code{airquality} data into a list of dataframes, e.g.\ one
dataframe for each month. This can be achieved by:
\begin{Schunk}
\begin{Sinput}
> x <- splitBy(~Month, data = aq)
\end{Sinput}
\end{Schunk}

Information about the grouping is stored as a dataframe 
in an attribute called \code{groupid}:
\begin{Schunk}
\begin{Sinput}
> attr(x, "groupid")
\end{Sinput}
\begin{Soutput}
  Month
1     5
2     6
\end{Soutput}
\end{Schunk}


\section{The \code{sampleBy} function} 
\label{sampleBy}

Suppose we want a random sample of 50 \% of the observations from a
dataframe. This can be achieved with:
\begin{Schunk}
\begin{Sinput}
> sampleBy(~1, frac = 0.5, data = aq)
\end{Sinput}
\end{Schunk}

Suppose instead that we want a  systematic sample of  every fifth
observation within each month. This is achieved with:
\begin{Schunk}
\begin{Sinput}
> sampleBy(~Month, frac = 0.2, data = aq, systematic = T)
\end{Sinput}
\end{Schunk}


\section{The \code{subsetBy} function} 
\label{subsetBy}

Suppose we want to take out those rows within each month for which the the
wind speed is larger than the mean wind speed (within the month). This
is achieved by:
\begin{Schunk}
\begin{Sinput}
> subsetBy(~Month, subset = "Wind>mean(Wind)", data = airquality)
\end{Sinput}
\end{Schunk}
Note that the statement \code{"Wind>mean(Wind)"} is evaluated within
each month.



\section{The \code{transformBy} function} 
\label{sec:transformby}

The \code{transformBy} function is analogous to the \code{transform}
function except that it works within groups. For example:
\begin{Schunk}
\begin{Sinput}
> transformBy(~Month, data = airquality, minW = min(Wind), maxW = max(Wind), 
+     chg = sum(range(Wind) * c(-1, 1)))
\end{Sinput}
\end{Schunk}





\section{The \code{esticon} function} 
\label{esticon}

Consider a linear model which explains \code{Ozone} as a linear
function of \code{Month} and \code{Wind}:
\begin{Schunk}
\begin{Sinput}
> airquality <- transform(airquality, Month = factor(Month))
> m <- lm(Ozone ~ Month * Wind, data = airquality)
> coefficients(m)
\end{Sinput}
\begin{Soutput}
(Intercept)      Month6      Month7      Month8      Month9        Wind 
     50.748     -41.793      68.296      82.211      23.439      -2.368 
Month6:Wind Month7:Wind Month8:Wind Month9:Wind 
      4.051      -4.663      -6.154      -1.874 
\end{Soutput}
\end{Schunk}

When a parameter vector $\beta$ of (systematic) effects have been
estimated, interest is often in a particular estimable function, i.e.\
linear combination $\lambda^\top \beta$ and/or testing the hypothesis 
$H_0: \lambda^\top \beta=\beta_0$ where $\lambda$ is a specific vector
defined by the user.

Suppose for example we want to calculate the expected difference in
ozone between consequtive months at wind speed 10 mph (which is about
the average wind speed over the whole period).

The \code{esticon} function provides a way of doing so. 
 We can specify several $\lambda$ vectors at the same time. For example

\begin{Schunk}
\begin{Sinput}
> Lambda
\end{Sinput}
\begin{Soutput}
     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
[1,]    0   -1    0    0    0    0  -10    0    0     0
[2,]    0    1   -1    0    0    0   10  -10    0     0
[3,]    0    0    1   -1    0    0    0   10  -10     0
[4,]    0    0    0    1   -1    0    0    0   10   -10
\end{Soutput}
\begin{Sinput}
> esticon(m, Lambda)
\end{Sinput}
\begin{Soutput}
Confidence interval ( WALD ) level = 0.95 
  beta0 Estimate Std.Error t.value  DF Pr(>|t|) Lower.CI Upper.CI
1     0   1.2871    10.238  0.1257 106  0.90019  -19.010   21.585
2     0 -22.9503    10.310 -2.2259 106  0.02814  -43.392   -2.509
3     0   0.9954     7.094  0.1403 106  0.88867  -13.069   15.060
4     0  15.9651     6.560  2.4337 106  0.01662    2.959   28.971
\end{Soutput}
\end{Schunk}

In other cases, interest is in testing a hypothesis of a contrast
$H_0: \Lambda \beta=\beta_0$ where $\Lambda$ is a matrix. For example
a test of no interaction between \code{Month} and \code{Wind} can be
made by testing jointly that the last four parameters in \code{m} are
zero (observe that the test is a Wald test): 

\begin{Schunk}
\begin{Sinput}
> Lambda
\end{Sinput}
\begin{Soutput}
     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
[1,]    0    0    0    0    0    0    1    0    0     0
[2,]    0    0    0    0    0    0    0    1    0     0
[3,]    0    0    0    0    0    0    0    0    1     0
[4,]    0    0    0    0    0    0    0    0    0     1
\end{Soutput}
\begin{Sinput}
> esticon(m, Lambda, joint.test = T)
\end{Sinput}
\begin{Soutput}
  X2.stat DF Pr(>|X^2|)
1   22.11  4  0.0001906
\end{Soutput}
\end{Schunk}

For a linear normal model, one would typically prefer to do a
likelihood ratio test instead. However, for generalized estimating
equations of glm--type (as dealt with in the packages \pkg{geepack}
and \pkg{gee}) there is no likelihood. In this case \code{esticon}
function provides an operational alternative.

Observe that another function for calculating contrasts as above is the
\code{contrast} function in the \pkg{Design} package but it applies to
a narrower range of models than \code{esticon} does.



\end{document}
